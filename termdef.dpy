.. _termdef:

TERMDEF: создает словарную запись
=================================

Этот генератор порождает словарную запись (glossary) вместо чанка.

#<syntax.termdef

Синтаксис генератора словарных записей
--------------------------------------

Синтаксис чанка этого типа таков (в тексте в примерах чанки начинаются с одного уголка специально, чтобы при обработки исходника этой документации
не порождались лишние чанки).
::

   <термин|type=termdef>>=
   Определение термина

Чанк заканчивается началом нового чанка (см. также :ref:`chunks`).

Данный генератор порождает RST словарную запись прямо по месту нахождения чанка.

В исходный код ничего не попадает.

#>syntax.termdef

<<Зависимости>>=
Используем наши утилиты для работы с чанками
<--->

import ch_utils

<<*genTermText|type=function>>=
< term: термин
< defn: определение
> строка: RST фрагмент для вставки в документацию
генерирует RST текст словарной статьи

Используется в генераторе моделей для генерации словарных записей в словаре.
<--->

    spacer = "   "
    cBody = ".. glossary::\n\n"
    cBody += spacer + term + " : " + term[0]+ "\n"
    for l in defn.split("\n"):
        cBody += spacer + spacer + l.strip() + "\n"
    cBody += "\n"
    return cBody
    
<<genChunkSrc|type=function>>=
< cStr: текст чанка
< addDetChunks=False: для генерации кода чанков второго уровня
> строка: питон для вставки в исходник
определение вырезается из исходника -  всегда возвращает пустую строку
<--->

    cBody = ""
    return cBody

<<genChunkDoc|type=function>>=
< cStr: текст чанка
> строка: RST для вставки в документацию
использует функцию выше
<--->
    
    chTitle = ch_utils.getChunkName(cStr)
    cTerm = ch_utils.getChunkBody(cStr).strip()

    return genTermText(chTitle,cTerm)
