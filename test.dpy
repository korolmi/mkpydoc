
Тестовый файл для mkpydoc
*************************

Зависимости
===========

<<Определение термина|type=termdef>>=
генератор glossary позволяет сделать словарную статью
из такого определения термина

Эта статья будет содержаться прямо в этом файле и будет доступна в общем словаре сфинкса
но не будет дублироваться в словарном документе (glossary.rst).

<<imports|type=simple>>=

import argparse

<<WebService|type=model>>=
тест для генератора model
<--->
* ws_name*: Имя сервиса (CharField, max_length=100) :: Краткое наименование веб сервиса
- ws_desc: Описание сервиса (TextField, default='')	:: Нормальное полное описание веб сервиса для документации в виде RST
- ws_impl_within_syscomp: Реализован в ФМ (fk.SysComp, default=None, related_name='ws_implemented') :: В каком функциональном модуле реализован веб сервис
- ws_called_from_syscomp: Вызывается из ФМ (mm.SysComp, default=None, related_name="ws_called") :: Из каких функциональных модулей вызывается данный веб сервис
- ws_person: Персонаж (CharField, max_length=1000, default=''):: none
= ADMIN: 2. Веб Сервисы

<<>>=

	DEFAULT_PK = 1

@
Простые чанки (генератор simple) и чанки второго уровня
=======================================================

<<Функция парсинга исходного файла>>=
Функция верхнего уровня, просто управляет
процессом генерации документации и кода (исходника на питоне)
<--->

def doParse ():
	""" парсит исходный файл и вызывает обработчиков """


<<Разбираемся с командной строкой>>=

	<<Разбор командной строки>>

<<Читаем весь файл>>=

	<<Работа с файлом>>

@

Тест для генератора интересных мест (algorithms)

#<testalgs.meta

<<getChunkName|type=function>>=
< aStr: чанк в виде строки (полностью)
< aStr2:
> res: 
> res2: имя чанка
тест для генератора function
<--->

	return	aStr.split("<<")[1].split(">>")[0].split("|")[0]

@

Формат определения чанка таков

   <имя чанка> | <опции через запятую>

Тип чанка - это одна из опций (type)

<<getChunkType|type=function>>=
< aStr: чанк в виде строки (полностью)
еще один тест для функций - не возвращает результат
<--->

	""" выдирает из первой строки чанка его тип """

	chDef = aStr.split("<<")[1].split(">>")[0]
	if chDef.find("type=")>0:
		chType = chDef.split("type=")[1].split(",")[0].strip()	# КОСТЫЛЬ: нужно проверять, что мы такой тип обрабатываем, дефолтить на SIMPLE и выдавать какое-то предупреждение
	else:
		chType = "simple"

	return chType

<<getJustDescr|type=function>>=
еще один тест для функций - здесь нет никаких
параметров, только описание
<--->

	""" выдирает из первой строки чанка его тип """

@
#>testalgs.meta

<<main>>=

doParse()

@

Чанки второго уровня
====================

#<testalgs.args

<<Разбор командной строки>>==
В формате argparse ниже достаточно понятно перечислены параметры командной строки
Потом переделаем на генератор...
<--->

parser = argparse.ArgumentParser(description='Преобразует .dpy в .py и .rst')
parser.add_argument('-i','--ifile', help='Входной файл ',required=True)
args = parser.parse_args()

@
#>testalgs.args

#<testalgs.files

<<Работа с файлом>>==

try:
	f = open( args.ifile, "r" )
except:
	print ( "Не получается открыть исходный файл {0}".format(args.ifile) )
	return 

buf = f.read()
f.close()

@
#>testalgs.files

