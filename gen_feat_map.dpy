.. _gen_feat_map:

GEN_FEAT_MAP: утилита для формирование Feature Map для системы
==============================================================

<<Карта фич|type=glossary>>=
Карта распределения фич (возможностей - Feature Map) по элементам системы. Цель составления - структурирование
технической документации по системе и привязка ее (документации) к визуальным компонентам системы.

Содержит два взгляда

* иерархический (см. ниже): распределяет фичи по компонентам системы
* исторический: распределяет фичи по степени усложнения и развития системы (по релизам)

Исторический взгляд облегчает изучение системы новыми сотрудниками.

Навеяно Story Map и книгой Patton-а.

В иерархическом взгляде предполагаем двухуровневую иерархию сущностей:

* элемент системы (в Story Map это активность - Activity)
* компонент элемента системы (в Story Map это шаг активности - Step)

Общая идея такова

* в какой-то нотации вести Feature Map
  * пока это чеквист, основные описания там, частично переехали сюда
* делать (вручную пока) файл, содержащий срез этой самой Feature Map
  * из чеквиста - это экспорт всего списка в формате OPML (с установленной галочкой task color)
* этой утилитой производить файл, которы будут являться частью документации на систему
* файл (пока - это reST) стандартным образом включаются в Sphinx документацию по системе

Структура результирующей Feature Map

Компоненты

* ФМ состоит из фич (тривиально, но так)
* фича состоит из
  * названия (текст элемента списка в чеквисте)
  * более подробного но краткого описания (заметки к элементу в чеквисте) [опц]
  * детализации (не зеленое вложенное в фичу дерево в чеквисте) [опц]
  * меток (тэгов в терминологии чеквиста) 
    * тэг фичи [опт] - если метки нет, то ссылка на нее из релиза будет сгенерирована программой 
    * тэг релиза [опт] - если метки нет, то фича никуда не входит
  * примеров использования (красное вложенное в фичу дерево в чеквисте) [опц]
* фичи бывают простые и сложные (так сейчас в чеквисте - подумать)
  * сложная фича - это главная фича для всех фич с одним и тем же тэгом (в чеквисте)
    * сложная фича имеет зеленый цвет

Утилита произведет 2 взгляда на фичи

* структурированный: 2 уровня вложенности
  * элемент системы (активность, синий фон в чеквисте)
  * подэлемент системы (шаг активности, зеленый фон в чеквисте)
  * и дальше идут фичи, относящиеся к подэлементу
* исторический: привязка (вхождение) фич в релизы (красный фон и тэги в чеквисте)

Для структурированного взгляда будет сгенерирована полная информация (все, что есть в чеквисте). Для главных фич будут указаны ссылки на дополнительные
фичи с тем, чтобы можно было понять - что еще входит в эту фичу.

Для неглавных - ссылки на главные (чтобы можно было понять, откуда взялась эта мелочь).

#TODO: пока не сделаны ссылки из неглавных фич на главную

Также в структурированном виде для главной фичи есть перечень всех входящих в нее не главных фич - там можно увидеть все фичи разом.

Для исторического будет выведено

* релиз (его атрибутика: название, смысл=заметка, дата выхода)
* входящие в него фичи (только название и ссылка на фичу)
  * для сложных - будут показаны главная и относящиеся к главной фиче дополнительные фичи (для последних - только название)

#TODO: пока не выводится атрибутика релиза (смысл)

В текстах поддерживаются ссылки в стиле Sphinx и любая (если будут исключения - опишем позднее) атрибутика reST - с их помощью можно ссылаться на относящиеся к тексту
элементы документации (понятия, алгоритмы и т.п.)

Кроме того, поддерживается возможность преобразования текст, оформленного специальным образом, на ссылку (типа :ref:): текст "см.:что-то:" будет заменен
на ":ref:`что-то <что-то>`". Как правило, такие ссылки идут на алгоритмы. Это сделано, в-частности, для того, чтобы не нужно было дважды писать "что-то" в примере выше.

Пример входного файла (из checkvist)

::

   <outline text="Тесты" bgColor="blue">
      <outline text="Редактирование теста" bgColor="green">
      <outline text="Главные параметры теста" tags="rfwb_v1" color="blue"/>
      <outline text="Кнопка Сохранить" tags="rfwb_v1" color="blue"/>
      <outline text="Кнопка Удалить" color="blue"/>
      <outline text="Список тестов и создание нового теста" tags="rfwb_v1" color="blue"/>
      <outline text="Подключение зависимостей" tags="rfwb_v3" color="blue"/>
      <outline text="Опции запуска" color="blue"/>
      <outline text="Удобное редактирование тела теста" color="blue">
         <outline text="Детали">
            <outline text="Редактор codemirror"/>
            <outline text="Визуализация табуляции"/>
            <outline text="Полноэкранный режим"/>
            <outline text="Подстановка параметров интерфейса"/>
            <outline text="Подстановка ключевых слов"/>
            <outline text="Подстановка параметров запуска"/>
            <outline text="Подстановка слов из библиотеки Builtin"/>
         </outline>
      </outline>
   </outline>
      
<<Синтаксис>>=

DELIM = "-"              # разделитель, который мы используем при формировании меток (для Sphinx)
TAG_STORY = "ust"        # префикс, с которого начинаются тэги фич в чеквисте 
TAG_AUTO = "auto"        # префикс, с которого будут начинаться созданные нами метки
REF_PREF = ["См.:","см.:"] # префикс, с которого начинаются ссылки на sphinx элементы
TAG_RELEASE = "rfwb"     # префикс, с которого начинаются тэги релизов в чеквисте
MAIN_FT_COLOR = "green"  # цвет главной фичи для сложных фич

SM_ROOT = "sm_root"      # тэг, которым помечен корень дерева feature map в чеквисте
REL_ROOT = "rel_root"    # тэг, которым помечен корень дерева релизов в чеквисте
       
LVL_CHARS = {            # настройка заголовков - как у нас будет оформлена структура reST документа
    0: "*",              # документ
    1: "=",              # разделы документа (пока это только фичи и релизы)
    2: "-",              # верхний уровень фич (активности в стори мапе), например, справочники
    3: "^"               # второй уровень фич (шаги активности в стори мапе), например, параметры интерфейса
}

<<Зависимости>>=

import argparse
import os
import xml.etree.ElementTree as ET

<<*outListItem|type=function>>=
< lvl: уровень элемента списка (начинаем с 1, 0 = заголовок статьи)
< txt: собственно, текст элемента
> строка: строка в формате reST
Абстрагирует нас от деталей представления списков разной глубины
<--->

    if lvl==4:
        resStr = ".. rubric:: " + txt + "\n"
    else:
        resStr = txt + "\n" + LVL_CHARS[lvl]*len(txt) + "\n"
       
    return resStr

<<outListChilds|type=function>>=
< i: элемент списка, корень иерархии
< p: заполнитель (пока непонятно, как будет в reST
> строка: элемент в виде иерархического списка в формате reST
Рекурсивная функция

<--->

    # пройдемся по деткам элемента и все сгенерим
    res = p + i.attrib["text"] + "\n"
    if len(i)>0: res += "\n"
    for dd in i:
        res += outListChilds ( dd, "  " + p )
    if len(i)>0: res += "\n"
       
    return res

<<cvtRef|type=function>>=
< txt: исходный текст
> строка: результирующая строка
Заменяет ссылки вида см.:что-то: на reST вариант :ref:`что-то <что-то>`
<--->

    for t in REF_PREF:
        resTxt = txt.split(t)[0]
        if txt.find(t)>=0:
            for ch in txt.split(t)[1:]:
                npos = ch.find(":")
                if npos>0: # в строке нет ошибок - действительно метка
                    resTxt += "см. :ref:`" + "{0} <{0}>".format(ch.split(":")[0]) + "`" + ch[npos+1:]
                else: # в строке ошибка - нет закрывающего двоеточия, делаем, чтобы ломалось
                    resTxt += "_err_ " + ch
        txt = resTxt

    return resTxt

<<outList|type=function>>=
< i: элемент списка, корень иерархии
> строка: дети элемента в виде иерархического списка в формате reST
Занимается рекурсивным созданием списка

<--->

    res = ""
    for dd in i:
        res += outListChilds ( dd, "* " )
       
    return res

<<fmtBlock|type=function>>=
< t: текст блока
< c: класс блока
> строка: отформатированное описание (reST)
Преобразует построчный текст (который уже в формате reST)
в контейнер заданного класса.

Получается красиво!
<--->

    res = ".. container:: {0}\n\n".format(c)
    t = t.replace("\r","")  # убираем лишние символы
    for l in t.split("\n"):
        res += "   " + cvtRef(l) + "\n"
    res += "\n"

    return res
                  
<<outItemContent|type=function>>=
< i: элемент списка
> строка: содержимое элемента в формате reST
Занимается сбором и форматированием

* описания элемента (notes)
* примеров использования (красные списки, вложенные в первый элемент красного цвета)
* детализации элемента (не красные списки, вложенные в элемент)
<--->

    # пройдемся по деткам элемента определенных типов и сгенерим детали
    res = ""
    for dd in i:
        if "type" in dd.attrib and dd.attrib["type"]=="note":     # описание
            res += "*Описание*:\n\n" + fmtBlock(dd.attrib["text"],"yellow") + "\n\n"
        elif "color" in dd.attrib and dd.attrib["color"]=="red":  # примеры использования
            res += "*Примеры использования*:\n\n" + fmtBlock(outList(dd),"red") + "\n"
        else:
            res += "*Детализация*:\n\n" + fmtBlock(outList(dd),"grey") + "\n"
       
    return res
       
<<doWork|type=function>>=
Функция, которая все и делает.

Два прохода по дереву фич

* на первом собирается ссылочная информация

    * состав сложных фич
    * состав релизов

* на втором генерируется reST текст

В качестве уникального ID фичи используется ее порядковый номер в дереве (в порядке прохода по дереву - он один и тот же для обоих проходов
алгоритма).
                
<--->

    <<GEN_FEAT_MAP: Разбор командной строки>>

    # парсим файл
    tree = ET.parse(args.ifile)
    root = tree.getroot()
    
    # встаем на начало Story Map
    sm = root[1][0]

    fm = None
    for c in sm:
       if "tags" in c.attrib and c.attrib["tags"].find(SM_ROOT)>=0:
           fm = c
       if "tags" in c.attrib and c.attrib["tags"].find(REL_ROOT)>=0:
           rm = c

    if fm is None:
       print("Нету сторимапа, делать нечего.")
       return

@
Немного про идею обработки:

* не все фичи имеют тэги, поэтому для каждой формируем авто тэг (вида auto-порядковый номер)
* считаем шаги обработки (фактически - порядковые номера всех фич), запоминаем в словаре номер шага -> тэг фичи
* формируем словарь тэг фичи -> набор меток фич, которые вошли в релиз (включая авто)
* формируем словарь, в котором по тэгу можно найти

  * текст фичи, тэг, номер шага обработки
  * для сложной фичи - еще набор таких же троек по всем входящим в сложную фичам

* преобразуем тэги деталей сложных фич: они изначально все имеют один и тот же тэг. Мы его меняем
  на уникальный, добавляя к нему порядковый номер фичи в списке деталей
                  
Потом простым ходом (второй проход) формируем RST текст.
<<>>=
                  
    resRst = ":tocdepth: 3\n\n"
    stepNo = 0    # номер шага - каждая фича (активность-шаг-фича) увеличивает шаг
    step2lab = {} # в этом наборе соответствие номера шага метке, которую надо ставить на этом шаге
    ftSet = {}    # набор по тэгу (оригинальному) содержит
                  # [текст,тэг,шаг][[текст,тэг,шаг]...]
    rel2ft = {}   # по тэгу релиза - [тэги фич - метки]
    ftNo = 1
                  
    # первый проход - формирование ftSet и step2lab
    for act in fm:
        for step in act:
            for ft in step:
                stepNo += 1
                # формируем метку
                if "tags" in ft.attrib and ft.attrib["tags"].find(TAG_STORY)>=0:  # относится к фиче, запоминаем в словаре
                    tag = ft.attrib["tags"][ft.attrib["tags"].find(TAG_STORY):].split(",")[0].replace("_","-")
                else: # не было метки по фиче - генерируем
                    tag = TAG_AUTO + DELIM + str(ftNo)
                    ftNo += 1
                step2lab[stepNo] = tag   # привязали тэг к номеру шага
                if tag not in ftSet:     # первый раз встретили эту фичу
                    ftSet[tag] = [ [ft.attrib["text"],tag,stepNo], [] ]
                else:                    # эту фичу уже встречали
                    if "color" in ft.attrib and ft.attrib["color"].find(MAIN_FT_COLOR)>=0:  # встретили главную фичу
                        ftText = ftSet[tag][0][0]
                        ftTag = ftSet[tag][0][1]
                        ftStep = ftSet[tag][0][2]
                        ftSet[tag][0][0] = ft.attrib["text"]
                        ftSet[tag][0][1] = tag
                        ftSet[tag][0][2] = stepNo
                        ftSet[tag][1].append([ftText,ftTag,ftStep])
                    else: # просто фича - добавляем в список
                        ftSet[tag][1].append([ft.attrib["text"],tag,stepNo])

    print ( str(ftSet) )
                  
    # переделываем метки для сложных фич
    for f in ftSet:
        if len(ftSet[f][1])>0: # сложная фича
            subNo = 1          # порядковый номер сабфичи
            for subf in ftSet[f][1]:
                print ( str(subf) )
                newLab = subf[1] + DELIM + str(subNo)
                step2lab[subf[2]] = newLab
                subf[1] = newLab
                subNo += 1

    stepNo = 0
    for act in fm:  # идем по активностям, формируем текст
        if "type" in act.attrib and act.attrib["type"]=="note": # есть заметка-описание
            resRst += outListItem(0,"Карта фич") + "\n"
            resRst += "*Описание*:\n\n" + fmtBlock(act.attrib["text"],"yellow") + "\n\n"
            resRst += outListItem(1,"Фичи (иерархический взгляд)") + "\n"
        else:
            resRst += outListItem(2,act.attrib["text"]) + "\n"
        for step in act:
            resRst += outListItem(3,step.attrib["text"]) + "\n"
            for ft in step:
                stepNo += 1       
                resRst += ".. _{0}:\n\n".format(step2lab[stepNo]) + outListItem(4,ft.attrib["text"]) + "\n"
                resRst += outItemContent(ft)

                if "color" in ft.attrib and ft.attrib["color"].find(MAIN_FT_COLOR)>=0:  # встретили главную фичу
                    if "tags" in ft.attrib and ft.attrib["tags"].find(TAG_STORY)>=0:  # есть тэг
                        tag = ft.attrib["tags"][ft.attrib["tags"].find(TAG_STORY):].split(",")[0].replace("_","-")
                    else:
                        print ( "No feature tag in MAIN story ({0})".format(ft.attrib["text"]) ) #TODO: непонятно, как нужно реагировать на такую ситуацию...
                        return
                    resRst += "``Включает также фичи``: "
                    subLst = []
                    for subf in ftSet[tag][1]:
                        subLst.append(" :ref:`{0} <{0}>` ".format(step2lab[subf[2]]))
                    resRst += ",".join(subLst) + "\n\n"
                if "tags" in ft.attrib and ft.attrib["tags"].find(TAG_RELEASE)>=0:  # относится к релизу - организуем кросс ссылки
                    rel = ft.attrib["tags"][ft.attrib["tags"].find(TAG_RELEASE):].split(",")[0].replace("_","-")
                    if rel not in rel2ft:
                        rel2ft[rel] = [ step2lab[stepNo] ]
                    else:
                        rel2ft[rel].append(step2lab[stepNo])
                    resRst += "``Входит в релиз``: :ref:`{0} <{0}>`\n\n".format(rel)
       
    # формируем релизы
    resRst += outListItem(1,"Релизы (исторический взгляд)") + "\n"
    for r in rm:
        if "type" in r.attrib:  # пропускаем заметки и проч
            continue
        relLab = ""
        relText = r.attrib["text"]
        if "tags" in r.attrib:
            rel = r.attrib["tags"][r.attrib["tags"].find(TAG_RELEASE):].split(",")[0].replace("_","-")
            relLab = ".. _{0}:\n\n".format(rel)
            relText += " ({0})".format(rel)
        resRst += "\n" + relLab + outListItem(2,relText) + "\n"
        if "tags" in r.attrib:
            if rel in rel2ft:
                if len(rel2ft[rel])>0:
                    resRst += "**Включает фичи**:\n\n"
                for f in rel2ft[rel]:
                    if f in ftSet: # только для одиночных и главных фич
                        resRst += "* " + ftSet[f][0][0] + " (*см. фичу* :ref:`{0} <{0}>`)\n\n".format(f)
                        if len(ftSet[f][1])>0:
                            for af in ftSet[f][1]:
                                resRst += "  * " + af[0] + "\n"
              
    of = open ( args.ofile, "w" )
    of.write(resRst)
    of.close()
    print(str(ftSet))
    print ("====")
    print ( resRst )
    print (str(rel2ft))

doWork()
    
@
#<algorithms.featmap

<<GEN_FEAT_MAP: Разбор командной строки>>==
Параметры запуска утилиты
<--->
parser = argparse.ArgumentParser(description='Формирует Feature Map для включения в документацию')
parser.add_argument('-i','--ifile', default='feat_map.xml', help='имя файла исходного файла (CheckVist)')
parser.add_argument('-o','--ofile', default='feat_map.rst', help='имя файла результата')
args = parser.parse_args()

@
#>algorithms.featmap

