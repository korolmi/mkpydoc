.. _function:

FUNCTION: генератор функций на питоне
=====================================

Этот генератор порождает определение функции (на питоне) и документацию по ней. Использует стандартную сигнатуру.

#TODO: чанк второго уровня включается в документации во фрагмент исходника, как правильнее

#<syntax.function

.. _functions:

Синтаксис генератора функций
----------------------------

Синтаксис чанка этого типа таков (в тексте в примерах чанки начинаются с одного уголка специально, чтобы при обработки исходника этой документации
не порождались лишние чанки).
::

   <[*]имя функции|type=function>>=
   < входной параметр: описание
   < входной параметр: описание
   ...
   > выходной параметр: описание
   Описание функции
   <--->
   Тело функции
   
Предполагаем, что

- двоеточие всегда есть (для параметров), даже если нет описания
- описание идет всегда после параметров
- описание параметра укладывается в одну строку
- наличие звездочки перед именем функции - первая функция файла, нужно обнулить референс и сгенерить заголовок

Генератор порождает не только красивые описания функций, но 
также и частичные файлы с референсом, имена имеют вид *frefs.имя_функции.restp*.

См. примеры в DPY исходнике данного файла...

**Константы, используемые в коде**

<<>>=
FC_IN_PAR = chr(60)   # начало входного параметра - меньше
FC_OUT_PAR = chr(62)  # начало выходного параметра - больше
FC_PAR_SEP = chr(58)  # разделитель параметра и его описания - двоеточие

#>syntax.function

<<Зависимости>>=
Используем наши утилиты по работе с чанками и по поддержке reST (в части таблиц)
<--->

import ch_utils
import rst_utils

<<*prepPars|type=function>>=
< aStr: строка описательной части функции (то, что до ---)
> список списков: см. ниже
> строка: собственно описание функции (без параметров)

разбирает строку описания и возвращает список параметров, каждый элемент списка - тоже список
        - тип (входной = True)
        - имя
        - описание

Дополнительный сервис: если нет входных или выходных параметров, то вместо имени соответствующего элемента в результирующий
список вставляется слово "нет".
<--->

    resList = []
    resStr = ""
    wasIn = False
    wasOut = False
    if len(aStr)>0:
        for l in aStr.split("\n"):
            if l.find(FC_IN_PAR)>=0 or l.find(FC_OUT_PAR)>=0:	# строка с параметром
                l = l.strip()
                if l[0]=='<':
                    wasIn = True
                else:
                    wasOut = True
                pt = ( l[0]=='<')
                pn = l[1:].split(FC_PAR_SEP)[0].strip()
                pd = l[1:].split(FC_PAR_SEP)[1].strip()
                resList.append( [pt,pn,pd] )
            else:
                resStr += l + "\n"

    # добавляем информацию об отсутствии параметров любого типа
    if not wasIn:
        resList.append( [True,"нет","входных параметров нет"] )
    if not wasOut:
        resList.append( [False,"нет","не возвращает результат"] )
                
    return resList, resStr

<<genChunkSrc|type=function>>=
< cStr: строка с чанком целиком
< addDetChunks=False: для генерации кода чанков второго уровня
> строка: код (строки с ньюлайнами), который просто переносится в исходник
возвращает код (строки с ньюлайнами), который просто переносится в исходник

Пока все описания опускаем - только суть

RETURN в конец функции также пока не вставляем
<--->
    cBody = ""
    fName = ch_utils.getChunkName(cStr).replace("*","")
    cHdr = "def {0}({1}):\n\n"
    parList = []
    cDescr = ch_utils.getChunkDescr ( cStr )
    lp,rd = prepPars(cDescr)
    cBody = ch_utils.getChunkBody ( cStr )
    for l in lp:		          # добавляем параметры
        if l[0] and l[1].find("нет")<0:	  # входной параметр и не добавленный автоматом
            parList.append( l[1] )
    cBody = cHdr.format(fName,",".join(parList)) + cBody

    return cBody

<<genChunkDoc|type=function>>=
< cStr: строка с чанком
< mName: имя модуля
> строка: текст документации (строки с ньюлайнами), который просто переносится в rst
метод производства rst (стандартный для генератора)

Название функции переносится в заголовок (и попадает в оглавление документа по исходнику).

Пока остановился на варианте явной таблицы в RST (с минусиками и звездочками). Сложно, но ... кому сейчас легко.

Дополнительно генерит референс, который отличается от описания только стилем имени функции
<--->

    # вставляем заголовок (для оглавления)
    fName = ch_utils.getChunkName(cStr)
    if fName.find("*")>=0:  # первая функция модуля - нужно создать файл с референсом
        fName = fName.replace("*","")
        f = open( "frefs."+mName+".rstp","w")
        mTitle = "Модуль :ref:`{0}`".format(mName)
        f.write(mTitle + "\n")
        f.write("-"*len(mTitle) + "\n")
    else:
        f = open( "frefs."+mName+".rstp","a")
        
    docStr = "Функция " + fName
    refStr = "**"+docStr+"**\n\n"
    docStr += "\n" + "-" * len(docStr) + "\n\n"
    cDescr = ch_utils.getChunkDescr ( cStr )
    lp, rd = prepPars(cDescr)
    if len(cDescr)>0:		# есть описательная часть
        if len(lp)>0:		# есть параметры
            resStr = rst_utils.genFuncParsTable(lp)
        resStr += rd
    
    # пишем референс информацию
    f.write ( refStr )
    f.write ( resStr )
    f.close()

    # собственно, код функции
    resStr += ".. code-block::  python\n\n"
    resStr += ch_utils.getChunkBody ( cStr, True )

    return docStr + resStr
    
